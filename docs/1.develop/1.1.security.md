安全
====

安全是指保护账户安全，通常分为认证和授权两个部分，认证即处理账户登录时的各种情况，授权即处理账户操作时的各种情况。

---

## 设计思路

基于前后端分离模式，前端通过`Vue Router`框架管理路由，后端使用`Spring Security`框架管理接口。

在访问前端页面时，由于不存在有效凭证而重定向到登录页面，此时需要通过用户名和密码进行认证。

当认证成功后，可以获取到对应的菜单列表，通过菜单数据来动态渲染路由。

前端每次发起请求时，后端会根据账户对应的权限列表，过滤未经授权的接口，避免非法访问。

### 认证

默认情况下，`Spring Security`内置登录页面，并且支持自定义登录页面和逻辑，以及自定义重定向相关的功能，比如错误页面、注销接口等。

由于前端部署为一个单独的 web 服务，可能与后端存在不同的域名及端口，因此会触发浏览器跨域限制。

虽然`Vue Router`本身可以绕开跨域限制，但`Spring Security`内置的重定向功能，又会跳出`Vue Router`的管理范围，所以必须自定义认证功能。

使用`Spring Security`框架自定义认证功能非常简单，只需要将`HttpSecurity`中的相关方法进行自定义即可。

参考代码如下：

```java

@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain webFilterChain(HttpSecurity http,
                                              LoginFailureHandler loginFailureHandler,
                                              LoginSuccessHandler loginSuccessHandler) {
        return http
                .authorizeRequests(urlRegistry -> urlRegistry
                        .anyRequest().authenticated())
                .formLogin(loginConfigurer -> loginConfigurer
                        .failureHandler(loginFailureHandler)
                        .successHandler(loginSuccessHandler))
                .exceptionHandling(handlingConfigurer -> handlingConfigurer
                        .accessDeniedHandler(new AccessDeniedHandlerImpl())
                        .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED)))
                .sessionManagement(managementConfigurer -> managementConfigurer
                        .invalidSessionStrategy((request, response) ->
                                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "invalidSessionStrategy"))
                        .sessionConcurrency(controlConfigurer -> controlConfigurer
                                .maximumSessions(1)
                                .expiredSessionStrategy(event ->
                                        event.getResponse().sendError(HttpServletResponse.SC_UNAUTHORIZED, "expiredSessionStrategy"))))
                .logout(logoutConfigurer -> logoutConfigurer
                        .logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler())
                        .deleteCookies("JSESSIONID"))
                .csrf().disable()
                .build();
    }
}
```

其中，`LoginFailureHandler`实现了`AuthenticationFailureHandler`接口，主要是对`AuthenticationException`异常进行分析，返回对应的错误提示。

`LoginSuccessHandler`实现了`AuthenticationSuccessHandler`接口，主要返回一个凭据给前端用于确认登录成功。

对`exceptionHandling`方法进行自定义，主要涉及两个方面：

其一，当所访问资源因权限不足而引发异常时，使用框架的一个默认实现，即返回 403 状态，而不是重定向到错误页面；

其二，当认证失败而引发异常时，替换重定向到登录页面的逻辑为返回 401 状态。

对`sessionManagement`方法进行自定义，也涉及到两个方面：

其一，认证成功后产生的会话，在指定时间内由于未操作而导致的会话过期，将返回 401 状态以及相关消息。

其二，对于会话的并发控制，最多只允许存在一个有效会话，最近一次认证成功产生的会话将替代上一次会话，如果因会话被替代而触发的会话过期，将返回 401 状态以及相关消息。

对`logout`方法进行自定义，如果会话注销成功，则返回 200 状态，而不需要后端进行重定向，同时会删除相关认证信息。

进行以上自定义后，当前端向后端发起请求，后端检测到请求未包含有效认证时，会返回 403 状态，通知前端需要进行认证。

认证失败时，不再重定向到内置的登录页面，而是返回一个 401 状态，通知前端提示重新认证。

认证成功后，每次请求会自动携带名为`SESSION`的`Cookie`数据，后端通过`Spring Security`分析当前请求，找到所属会话及对应账户。

这就是认证的基本流程，`Spring Security`还负责处理更多安全方面的问题，由于篇幅有限，这里不再赘述，请参考[官方文档][1]。

### 授权

授权实际上分为两部分，其一为后端返回给前端的菜单数据，其二为后端定义的权限数据。

正常情况下，`Vue Router`通过菜单数据渲染路由，用户只能看到自己的路由，没有权限的路由无法看到。

通过路由可以跳转到对应页面，页面中会展示用户有权限的操作按钮，没有权限的操作按钮将不展示。

这些操作按钮可能关联一个弹窗、一次请求或是其他相关操作。

对于操作按钮关联的请求来说，必须是账户已授权才能访问，所以后端需要校验相关权限数据。

通过开启`Spring Security`的`@EnableGlobalMethodSecurity(prePostEnabled = true)`全局方法安全注解，然后在每个需要权限的方法上，添加`@PreAuthorize`的注解，此时会检测当前会话中的认证信息，是否拥有指定的权限，如果检测通过则允许调用，否则将抛出`AccessDeniedException`异常，随后通过`AccessDeniedHandler`接口的`AccessDeniedHandlerImpl`实现类，返回给前端 403 状态。

至于更细粒度的数据权限，可以通过`spring-security-acl`框架进行管理，它将在查询数据库时进行过滤，而不是在内存中过滤。

[1]:https://docs.spring.io/spring-security/reference/5.7/index.html